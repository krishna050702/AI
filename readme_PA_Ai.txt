Name:- Krishna Mundada
Roll no:- E-45

Programming Assignment 1 -- Artificial intelligence 

Problem Statement:-
Design a comparative model for Romania graph. Implement Depth first search, Depth limited Search
(Depth will be 3), Iterative deepening DFS, Best First Search and A* Algorithm. Find and Print
1) Number of nodes generated by each algorithm.
2) Depth at which the solution is present
Also, show/print the path find by each algorithm.
Start node: Arad
Goal node: Bucharest
Use the heuristic information, which is provided in a book.


==>
All data i.e graph , heuristics is stored in Data.py file

Depth First Search:- (Search through the successors of a problem to find a goal) if we do DFS by tree search then we will get stuck in a loop
visited array is to keep track of visited cities
to avoid the repeated visiting of the cities
d_path is array to print the path choose+1 in dict that is Aarad so we got  the first node Arad
gNodes is total no of generated nodes
find the value which is not 0 in first it is Zernid and it city should be not visited
and if we got Bucharest break the loop
increase the cost by adding the 
again calling the function , then the node will be Zernid it will search the possibilities from zernid now


Depth Limit Search 
it will search up to a particular limit here limit is given 3
int _stack we have putted Arad 
the value popped will be stored in a list 
then will check if it is visited 
if it is Bucharest then return 
if dept is not 3 then increase the count 
then find all the sub nodes of the current node
i is current vertices 
if count is 3 that is depth reached 
here we are doing backtracking so having a record of previous node depth

Path function :-
 a list is generated in that we have all the nodes generated
last node is 3,5
so we having a loop till depth less than 3
reverse is used to calculate the cost in t index is saved


IDDFS:- (ITERATIVE DEEPENING DFS)
flag is 1 when it is on Bucharest 
in IDDFS if we go to depth 2 then search all the possible nodes in depth 2 
then we go to depth 3 
in path till we don't get depth 0 the loop  goes


BFS (best first search)
it works on heuristic function the node with least heuristic function is chosen 
we use queue for fifo
here we are doing sort also to find min heuristic so we can pop other nodes
.store is used to store the heuristic values so we can use it to calculate the cost


A star 
in this we f(n) +g(n)
in this we do min heuristic function and also add its path and see which is lesser 
the lesser value one is selected and rest is done same as BFS
